<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Monitoring - Model Monitoring Phase</title>
    <link rel="stylesheet" href="../shared/shared.css">
    <style>
        .monitoring-hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
            color: var(--matrix-green-bright);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 10px var(--matrix-green-bright);
        }

        .system-status {
            display: flex;
            gap: 30px;
        }

        .status-item {
            text-align: center;
        }

        .status-label {
            font-size: 24px;
            color: var(--matrix-green-medium);
        }

        .status-value {
            font-size: 32px;
            font-weight: bold;
        }

        .base-status {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .base-indicator {
            width: 20px;
            height: 20px;
            border: 2px solid var(--matrix-green-bright);
            background: var(--matrix-green-bright);
            border-radius: 3px;
        }

        .base-indicator.destroyed {
            background: transparent;
            border-color: var(--matrix-green-dark);
        }

        .controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: var(--matrix-green-dark);
            font-family: 'Courier New', monospace;
            font-size: 20px;
            line-height: 1.4;
        }

        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--matrix-green-bright);
            border-radius: 50%;
            pointer-events: none;
            z-index: 200;
            transform: translate(-50%, -50%);
            opacity: 0.8;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: var(--matrix-green-bright);
        }

        .crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="monitoring-hud">
            <div class="system-status">
                <div class="status-item">
                    <div class="status-label">SCORE</div>
                    <div class="status-value" id="score">00000000</div>
                </div>
                <div class="status-item">
                    <div class="status-label">WAVE</div>
                    <div class="status-value" id="wave">1</div>
                </div>
                <div class="status-item">
                    <div class="status-label">PHASE</div>
                    <div class="status-value">MONITORING</div>
                </div>
            </div>

            <div class="base-status">
                <div class="status-label">SYSTEMS:</div>
                <div class="base-indicator" id="base-0"></div>
                <div class="base-indicator" id="base-1"></div>
                <div class="base-indicator" id="base-2"></div>
            </div>
        </div>

        <div class="controls-help">
            <div>MOUSE: Aim • CLICK: Launch Defense Missile</div>
            <div>P/ESC: Pause • Defend ML systems from anomalies!</div>
        </div>

        <div class="crosshair" id="crosshair"></div>
    </div>

    <!-- p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>

    <!-- Shared utilities -->
    <script src="../shared/shared.js"></script>

    <!-- Game script -->
    <script>
        // Model Monitoring Game - Missile Command Style
        // Defend ML systems from anomaly missiles and model drift

        // Game state
        let gameState = 'playing'; // 'playing', 'paused', 'gameOver', 'victory', 'waveCleared'
        let score = 0;
        let wave = 1;
        let gameOver = false;
        let gameStartTime;

        // Game objects
        let bases = [];
        let enemies = [];
        let missiles = [];
        let explosions = [];
        let fireworks = [];

        // Game constants
        const NUM_BASES = 3;
        const BASE_WIDTH = 120;
        const BASE_HEIGHT = 50;
        const MISSILE_SPEED = 8;
        const EXPLOSION_RADIUS_MAX = 80;
        const EXPLOSION_DURATION = 40;

        // Enemy definitions (ML monitoring threats) - 4x points for faster scoring
        const ENEMY_DEFINITIONS = [
            { name: "Data Drift", speed: 0.8, points: 40, color: [60, 180, 255], size: 50 },
            { name: "Model Decay", speed: 1.0, points: 60, color: [100, 150, 250], size: 56 },
            { name: "Anomaly Spike", speed: 1.2, points: 80, color: [255, 200, 80], size: 44 },
            { name: "Performance Drop", speed: 0.6, points: 100, color: [230, 80, 80], size: 70 }
        ];

        const BOSS_DEFINITION = {
            name: "Production Outage",
            speed: 0.4,
            points: 500,
            color: [0, 100, 50],
            size: 100,
            health: 10
        };

        // Single level management
        let enemySpawnTimer = 0;
        let enemySpawnInterval = 1500; // Faster initial spawn rate for presentation
        let regularEnemiesSpawned = 0;
        let maxRegularEnemies = 10; // Spawn 10 regular threats before boss (faster progression)
        let isBossActive = false;
        let bossDefeatedThisGame = false;
        let bossSpawnTime = 15000; // Boss spawns after 15 seconds (faster for presentation)

        // System Reset powerup
        let powerup = null;
        let hasPowerup = false;
        let powerupSpawned = false;
        let powerupSpawnedWithBoss = false; // Track if powerup spawned with boss
        let systemResetDeployment = null; // Active deployment manager

        function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent(document.querySelector('.game-container'));

            colorMode(HSB, 360, 100, 100, 100);

            // Initialize bases (ML systems to defend)
            initializeBases();

            gameStartTime = millis();

            console.log('Model Monitoring game initialized');
        }

        function draw() {
            background(220, 10, 10, 35); // Original background

            if (gameState === 'playing') {
                updateGame();
            } else if (gameState === 'paused') {
                displayPauseMenu();
            } else if (gameState === 'gameOver') {
                displayGameOver();
            } else if (gameState === 'victory') {
                displayVictory();
            } else if (gameState === 'waveCleared') {
                displayWaveCleared();
            }

            updateUI();
            updateCrosshair();
        }

        function initializeBases() {
            bases = [];
            const baseSpacing = width / (NUM_BASES + 1);

            for (let i = 0; i < NUM_BASES; i++) {
                const x = baseSpacing * (i + 1);
                const y = height - 120; // Moved higher to avoid UI text overlap
                bases.push(new Base(x, y, i));
            }
        }

        function updateGame() {
            if (gameOver) return;

            // Spawn regular enemies
            if (millis() - enemySpawnTimer > enemySpawnInterval &&
                regularEnemiesSpawned < maxRegularEnemies &&
                !isBossActive) {
                spawnEnemy();
                enemySpawnTimer = millis();
                regularEnemiesSpawned++;

                // Gradually increase spawn rate for fast presentation gameplay
                enemySpawnInterval = Math.max(600, 1500 - (regularEnemiesSpawned * 100));
            }

            // Spawn boss after time limit or when regular enemies are done
            if ((millis() - gameStartTime > bossSpawnTime || regularEnemiesSpawned >= maxRegularEnemies) &&
                !isBossActive && !bossDefeatedThisGame && enemies.length === 0) {
                spawnBoss();
                isBossActive = true;

                // Spawn powerup immediately when boss appears
                if (!powerupSpawnedWithBoss && !hasPowerup && !powerup) {
                    powerup = new SystemResetPowerup();
                    powerupSpawnedWithBoss = true;
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update();
                enemies[i].render();

                // Check if enemy reached a base
                if (enemies[i].hasReachedTarget()) {
                    // Destroy the base
                    const targetBase = enemies[i].targetBase;
                    if (targetBase && !targetBase.isDestroyed) {
                        targetBase.destroy();
                        explosions.push(new Explosion(targetBase.x, targetBase.y, EXPLOSION_RADIUS_MAX));

                        // If this was the boss, check if all models are destroyed
                        if (enemies[i].name === "Production Outage") {
                            // Boss continues to next target until all models destroyed
                            let remainingModels = bases.filter(base => !base.isDestroyed);
                            if (remainingModels.length > 0) {
                                // Boss targets next available model and recalculates trajectory
                                enemies[i].retarget(remainingModels[0]);
                                // Don't remove boss, let it continue
                                continue;
                            }
                        }
                    }
                    enemies.splice(i, 1);
                    continue;
                }

                // Remove if off screen
                if (enemies[i].y > height + 50) {
                    enemies.splice(i, 1);
                }
            }

            // Update missiles
            for (let i = missiles.length - 1; i >= 0; i--) {
                missiles[i].update();
                missiles[i].render();

                if (missiles[i].hasReachedTarget()) {
                    explosions.push(new Explosion(missiles[i].targetX, missiles[i].targetY, EXPLOSION_RADIUS_MAX));
                    missiles.splice(i, 1);
                } else if (missiles[i].isOffScreen()) {
                    missiles.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].update();
                explosions[i].render();

                // Check explosion-enemy collisions
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (explosions[i].hits(enemies[j])) {
                        // Check if this is the boss - only System Reset can damage it
                        if (enemies[j].name === "Production Outage") {
                            // Boss can only be damaged by System Reset powerup explosions
                            if (explosions[i].isSystemReset) {
                                score += enemies[j].points;
                                bossDefeatedThisGame = true;
                                enemies.splice(j, 1);
                            }
                            // Regular missiles have no effect on boss
                        } else {
                            // Regular enemies take damage from any explosion
                            score += enemies[j].points;
                            enemies.splice(j, 1);
                        }
                    }
                }

                if (explosions[i].isDead()) {
                    explosions.splice(i, 1);
                }
            }

            // Render bases
            for (let base of bases) {
                base.render();
            }

            // Powerup now spawns with boss appearance (handled above)
            // Legacy score-based spawning removed

            // Update powerup
            if (powerup) {
                powerup.update();
                powerup.render();

                // Check collision with missiles (shoot to collect)
                for (let i = missiles.length - 1; i >= 0; i--) {
                    if (dist(missiles[i].x, missiles[i].y, powerup.pos.x, powerup.pos.y) < powerup.r + 10) {
                        hasPowerup = true;
                        powerup = null;
                        missiles.splice(i, 1); // Remove the missile that hit it
                        break;
                    }
                }
            }

            // Check victory condition
            if (bossDefeatedThisGame && enemies.length === 0) {
                gameState = 'victory';
            }

            // Update fireworks
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                fireworks[i].render();
                if (fireworks[i].isDead()) {
                    fireworks.splice(i, 1);
                }
            }

            // Update System Reset deployment if active
            if (systemResetDeployment && systemResetDeployment.isActive) {
                systemResetDeployment.update();

                // Clean up deployment when complete
                if (systemResetDeployment.isComplete()) {
                    systemResetDeployment = null;
                }
            }

            // Check game over
            if (bases.every(base => base.isDestroyed)) {
                gameOver = true;
                gameState = 'gameOver';
            }
        }

        function spawnEnemy() {
            const enemyType = ENEMY_DEFINITIONS[Math.floor(Math.random() * ENEMY_DEFINITIONS.length)];
            const startX = Math.random() * width;
            const targetBase = bases[Math.floor(Math.random() * bases.length)];

            enemies.push(new Enemy(startX, -50, targetBase, enemyType));
        }

        function spawnBoss() {
            const startX = width / 2; // Boss spawns in center
            const targetBase = bases.find(base => !base.isDestroyed) || bases[0]; // Target first alive base
            enemies.push(new Enemy(startX, -100, targetBase, BOSS_DEFINITION));
        }

        function updateCrosshair() {
            const crosshair = document.getElementById('crosshair');
            crosshair.style.left = mouseX + 'px';
            crosshair.style.top = mouseY + 'px';
        }

        function updateUI() {
            document.getElementById('score').textContent = MLOpsUtils.formatScore(score);
            document.getElementById('wave').textContent = wave;

            // Update base indicators
            for (let i = 0; i < bases.length; i++) {
                const indicator = document.getElementById(`base-${i}`);
                if (bases[i].isDestroyed) {
                    indicator.classList.add('destroyed');
                } else {
                    indicator.classList.remove('destroyed');
                }
            }
        }

        function displayPauseMenu() {
            fill(0, 0, 0, 80);
            rect(0, 0, width, height);

            MLOpsUtils.drawGlowText(drawingContext, 'MONITORING PAUSED', width/2, height/2 - 60, 48);
            MLOpsUtils.drawGlowText(drawingContext, 'Press P to continue', width/2, height/2, 24);
            MLOpsUtils.drawGlowText(drawingContext, 'Press ESC to return to hub', width/2, height/2 + 40, 18);
        }

        function displayGameOver() {
            fill(0, 0, 0, 80);
            rect(0, 0, width, height);

            MLOpsUtils.drawGlowText(drawingContext, 'SYSTEM FAILURE', width/2, height/2 - 60, 48);
            MLOpsUtils.drawGlowText(drawingContext, 'ALL ML SYSTEMS COMPROMISED', width/2, height/2 - 20, 24);
            MLOpsUtils.drawGlowText(drawingContext, `Final Score: ${MLOpsUtils.formatScore(score)}`, width/2, height/2 + 40, 24);
            MLOpsUtils.drawGlowText(drawingContext, 'Press R to retry or ESC to return to hub', width/2, height/2 + 80, 18);
        }

        function displayVictory() {
            // Create fireworks continuously like data cleaning game
            if (frameCount % 10 === 0) {
                let x = random(width);
                let y = random(height * 0.2, height * 0.5);
                for (let i = 0; i < 50; i++) {
                    fireworks.push(new Firework(x, y));
                }
            }

            // Update and render fireworks
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                fireworks[i].render();
                if (fireworks[i].isDead()) {
                    fireworks.splice(i, 1);
                }
            }

            // Victory text matching data cleaning style
            fill(120, 100, 100);
            textSize(72);
            textAlign(CENTER, CENTER);
            text("YOU WIN!", width / 2, height / 2 - 100);

            textSize(36);
            fill(180, 80, 90);
            text("ML Systems Secured!", width / 2, height / 2 - 20);

            textSize(24);
            fill(120, 70, 80);
            text(`Final Score: ${score}`, width / 2, height / 2 + 40);

            textSize(20);
            fill(120, 60, 70);
            text("Press R to play again", width / 2, height / 2 + 140);

            textSize(16);
            text("Press ESC to return to hub", width / 2, height / 2 + 170);
        }

        function displayWaveCleared() {
            fill(0, 0, 0, 60);
            rect(0, 0, width, height);

            MLOpsUtils.drawGlowText(drawingContext, `WAVE ${wave} CLEARED`, width/2, height/2 - 40, 48);
            MLOpsUtils.drawGlowText(drawingContext, 'Systems holding steady...', width/2, height/2 + 20, 24);
            MLOpsUtils.drawGlowText(drawingContext, 'Press SPACE for next wave', width/2, height/2 + 60, 18);
        }

        function mousePressed() {
            if (gameState === 'playing') {
                if (hasPowerup) {
                    // Deploy System Reset - massive defense grid
                    deploySystemReset();
                    hasPowerup = false;
                    // Victory will be triggered by the deployment manager
                } else {
                    // Launch defensive missile
                    const nearestBase = findNearestBase(mouseX, mouseY);
                    if (nearestBase && !nearestBase.isDestroyed) {
                        missiles.push(new Missile(nearestBase.x, nearestBase.y, mouseX, mouseY));
                    }
                }
            }
        }

        function deploySystemReset() {
            // Create deployment manager to handle the entire 8-second sequence
            systemResetDeployment = new SystemResetDeployment();
            console.log('System Reset deployment initiated - 8-second sequence started');
        }

        function findNearestBase(x, y) {
            let nearest = null;
            let minDist = Infinity;

            for (let base of bases) {
                if (!base.isDestroyed) {
                    const d = dist(x, y, base.x, base.y);
                    if (d < minDist) {
                        minDist = d;
                        nearest = base;
                    }
                }
            }

            return nearest;
        }

        function keyPressed() {
            if (gameState === 'playing') {
                if (key === 'p' || key === 'P' || keyCode === ESCAPE) {
                    gameState = 'paused';
                }
            } else if (gameState === 'paused') {
                if (key === 'p' || key === 'P') {
                    gameState = 'playing';
                } else if (keyCode === ESCAPE) {
                    returnToHub();
                }
            } else if (gameState === 'gameOver') {
                if (key === 'r' || key === 'R') {
                    resetGame();
                } else if (keyCode === ESCAPE) {
                    returnToHub();
                }
            } else if (gameState === 'victory') {
                if (key === 'r' || key === 'R') {
                    resetGame();
                    gameState = 'playing';
                } else if (keyCode === ESCAPE) {
                    returnToHub();
                }
            } else if (gameState === 'waveCleared') {
                if (key === ' ' || keyCode === ENTER) {
                    nextWave();
                }
            }
        }

        function nextWave() {
            wave++;
            enemiesThisWave = Math.min(5 + wave * 2, 15);
            enemiesSpawnedThisWave = 0;
            enemySpawnInterval = Math.max(1000, 2000 - wave * 100);
            gameState = 'playing';
        }

        function resetGame() {
            score = 0;
            wave = 1;
            gameOver = false;
            gameState = 'playing';
            enemies = [];
            missiles = [];
            explosions = [];
            fireworks = [];
            regularEnemiesSpawned = 0;
            enemySpawnInterval = 1500;
            isBossActive = false;
            bossDefeatedThisGame = false;
            powerup = null;
            hasPowerup = false;
            powerupSpawned = false;
            powerupSpawnedWithBoss = false;
            systemResetDeployment = null; // Reset deployment manager
            gameStartTime = millis();

            initializeBases();
        }

        // Firework class for victory celebrations
        class Firework {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(random(2, 10));
                this.acc = createVector(0, 0);
                this.lifespan = 255;
                this.hue = random(80, 180);
            }

            update() {
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.mult(0);
                this.lifespan -= 4;
                this.vel.mult(0.95);
            }

            render() {
                push();
                stroke(this.hue, 80, 100, this.lifespan);
                strokeWeight(3);
                point(this.pos.x, this.pos.y);
                pop();
            }

            isDead() {
                return this.lifespan < 0;
            }
        }

        // System Reset Deployment Manager
        class SystemResetDeployment {
            constructor() {
                this.startTime = millis();
                this.duration = 8000; // 8 seconds total effect
                this.isActive = true;
                this.explosionSchedule = [];
                this.flashSchedule = [];
                this.spawnedExplosions = new Set();
                this.spawnedFlashes = new Set();
                this.hasTriggeredVictory = false;
                
                // Configurable phase duration ratios (proportional to total duration)
                this.explosionPhaseRatio = 0.625; // 5/8 of total (explosions spawn over first 62.5%)
                this.flashStartRatio = 0.125; // 1/8 of total (flashes start at 12.5%)
                this.flashEndRatio = 0.8; // 4/5 of total (flashes end at 80%)
                this.victoryRatio = 1.0; // Victory triggers at 100% of total duration

                this.generateSpawnSchedule();
            }

            generateSpawnSchedule() {
                // Generate grid explosion schedule (proportional to explosion phase)
                let explosionId = 0;
                let explosionPhaseDuration = this.duration * this.explosionPhaseRatio;
                for (let x = 100; x < width - 100; x += 120) {
                    for (let y = 50; y < height - 150; y += 120) {
                        this.explosionSchedule.push({
                            id: explosionId++,
                            x: x + random(-30, 30),
                            y: y + random(-30, 30),
                            spawnTime: random(0, explosionPhaseDuration), // Spread over explosion phase
                            duration: this.duration * 0.375 // Each explosion lasts 37.5% of total duration (3/8)
                        });
                    }
                }

                // Generate flash schedule (proportional timing)
                let flashStart = this.duration * this.flashStartRatio;
                let flashEnd = this.duration * this.flashEndRatio;
                let flashPhaseDuration = flashEnd - flashStart;
                let numFlashes = 10;
                
                for (let i = 0; i < numFlashes; i++) {
                    this.flashSchedule.push({
                        id: i,
                        spawnTime: flashStart + (i * flashPhaseDuration / numFlashes), // Evenly distributed over flash phase
                        duration: this.duration * 0.25 // Each flash lasts 25% of total duration (2/8)
                    });
                }
            }

            update() {
                if (!this.isActive) return;

                let elapsed = millis() - this.startTime;

                // Spawn grid explosions
                for (let explosion of this.explosionSchedule) {
                    if (!this.spawnedExplosions.has(explosion.id) && elapsed >= explosion.spawnTime) {
                        let systemResetExplosion = new Explosion(explosion.x, explosion.y, EXPLOSION_RADIUS_MAX * 2);
                        systemResetExplosion.isSystemReset = true;
                        systemResetExplosion.startTime = millis();
                        systemResetExplosion.duration = explosion.duration;
                        explosions.push(systemResetExplosion);
                        this.spawnedExplosions.add(explosion.id);
                    }
                }

                // Spawn screen flashes
                for (let flash of this.flashSchedule) {
                    if (!this.spawnedFlashes.has(flash.id) && elapsed >= flash.spawnTime) {
                        let flashExplosion = new Explosion(width/2, height/2, width);
                        flashExplosion.isSystemReset = true;
                        flashExplosion.startTime = millis();
                        flashExplosion.duration = flash.duration;
                        explosions.push(flashExplosion);
                        this.spawnedFlashes.add(flash.id);
                    }
                }

                // Trigger victory at proportional time (75% of total duration)
                if (!this.hasTriggeredVictory && elapsed >= this.duration * this.victoryRatio) {
                    this.triggerVictory();
                    this.hasTriggeredVictory = true;
                }

                // Check if deployment is complete
                if (elapsed >= this.duration) {
                    this.isActive = false;
                }
            }

            triggerVictory() {
                // Clear all enemies and trigger victory
                for (let enemy of enemies) {
                    // Create particles for visual effect
                    for (let j = 0; j < 5; j++) {
                        let particleX = enemy.x + random(-20, 20);
                        let particleY = enemy.y + random(-20, 20);
                        fireworks.push(new Firework(particleX, particleY));
                    }
                    score += enemy.points;
                }
                enemies = [];
                bossDefeatedThisGame = true;
                gameState = 'victory';
                console.log('Victory state set! System Reset deployment complete');
            }

            isComplete() {
                return !this.isActive;
            }
        }

        function completeGame() {
            console.log('Returning to hub...');
            // Simple redirect back to main page - no completion overlay
            window.location.href = '../index.html';
        }

        function returnToHub() {
            console.log('Returning to hub...');
            // Simple redirect back to main page - no completion overlay
            window.location.href = '../index.html';
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            initializeBases();
        }

        // System Reset Powerup class (based on data cleaning powerup)
        class SystemResetPowerup {
            constructor() {
                this.pos = createVector(random(width * 0.2, width * 0.8), random(height * 0.2, height * 0.6));
                this.r = 30;
                this.angle = 0;
                this.floatOffset = 0;
            }

            update() {
                this.angle += 0.02;
                this.floatOffset = sin(frameCount * 0.05) * 10;
            }

            render() {
                push();
                translate(this.pos.x, this.pos.y + this.floatOffset);
                rotate(this.angle);

                // Draw Gemini-style concave diamond
                noFill();
                strokeWeight(3);
                // Animated gradient effect
                let hue = (frameCount * 2) % 360;
                stroke(hue, 100, 100);

                // Concave diamond shape using quadratic curves
                let s = this.r; // Half size for easier calculations
                let valleyDepthFactor = 0.8; // How concave the shape is (0 = diamond, 1 = very pinched)

                // Outer Tips
                let tipTop = { x: 0, y: -s };
                let tipRight = { x: s, y: 0 };
                let tipBottom = { x: 0, y: s };
                let tipLeft = { x: -s, y: 0 };

                // Control Points for concave curves
                let controlDist = s * (1 - valleyDepthFactor);
                let cpTopRight = { x: controlDist, y: -controlDist };
                let cpBottomRight = { x: controlDist, y: controlDist };
                let cpBottomLeft = { x: -controlDist, y: controlDist };
                let cpTopLeft = { x: -controlDist, y: -controlDist };

                beginShape();
                vertex(tipTop.x, tipTop.y);
                quadraticVertex(cpTopRight.x, cpTopRight.y, tipRight.x, tipRight.y);
                quadraticVertex(cpBottomRight.x, cpBottomRight.y, tipBottom.x, tipBottom.y);
                quadraticVertex(cpBottomLeft.x, cpBottomLeft.y, tipLeft.x, tipLeft.y);
                quadraticVertex(cpTopLeft.x, cpTopLeft.y, tipTop.x, tipTop.y);
                endShape();

                // Inner diamond with same shape
                scale(0.6);
                beginShape();
                vertex(tipTop.x, tipTop.y);
                quadraticVertex(cpTopRight.x, cpTopRight.y, tipRight.x, tipRight.y);
                quadraticVertex(cpBottomRight.x, cpBottomRight.y, tipBottom.x, tipBottom.y);
                quadraticVertex(cpBottomLeft.x, cpBottomLeft.y, tipLeft.x, tipLeft.y);
                quadraticVertex(cpTopLeft.x, cpTopLeft.y, tipTop.x, tipTop.y);
                endShape();

                pop();

                // Label (outside the rotation)
                push();
                fill(120, 100, 100);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(14);
                text("SYSTEM RESET", this.pos.x, this.pos.y + this.r + this.floatOffset + 20);
                pop();
            }
        }

        // Game classes
        class Base {
            constructor(x, y, id) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.width = BASE_WIDTH;
                this.height = BASE_HEIGHT;
                this.isDestroyed = false;

                // ML Model names
                const modelNames = ["Neural Net", "XGBoost", "Random Forest"];
                this.modelName = modelNames[id] || `Model ${id + 1}`;
            }

            render() {
                if (!this.isDestroyed) {
                    push();

                    // Dark background for contrast
                    fill(120, 30, 20);
                    stroke(120, 100, 100);
                    strokeWeight(3);
                    rectMode(CENTER);
                    rect(this.x, this.y, this.width, this.height, 8);

                    // Server rack lines for ML model appearance
                    stroke(120, 80, 60);
                    strokeWeight(1);
                    for (let i = 0; i < 3; i++) {
                        let yOffset = -this.height/2 + 12 + i * 12;
                        line(this.x - this.width/2 + 8, this.y + yOffset,
                             this.x + this.width/2 - 8, this.y + yOffset);
                    }

                    // Bright model name label for contrast
                    fill(120, 100, 100);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(16);
                    text(this.modelName, this.x, this.y);

                    // Status indicator
                    fill(120, 100, 100);
                    circle(this.x, this.y - this.height/2 - 8, 6);

                    pop();
                } else {
                    // Destroyed model
                    push();
                    fill(0, 80, 30);
                    stroke(0, 100, 60);
                    strokeWeight(2);
                    rectMode(CENTER);
                    rect(this.x, this.y, this.width, this.height, 8);

                    fill(0, 100, 100);
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(20);
                    text("OFFLINE", this.x, this.y);
                    pop();
                }
            }

            destroy() {
                this.isDestroyed = true;
            }
        }

        class Enemy {
            constructor(x, y, targetBase, enemyType) {
                this.x = x;
                this.y = y;
                this.targetBase = targetBase;
                this.name = enemyType.name;
                this.speed = enemyType.speed;
                this.points = enemyType.points;
                this.color = enemyType.color;
                this.size = enemyType.size;
                this.health = enemyType.health || 1;

                // Calculate trajectory to target
                if (targetBase) {
                    const dx = targetBase.x - this.x;
                    const dy = targetBase.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                } else {
                    this.vx = 0;
                    this.vy = this.speed;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            render() {
                push();

                // Draw enemy with enhanced glow effects
                // Outer glow ring
                fill(0, 100, 100, 30);
                noStroke();
                ellipse(this.x, this.y, this.size * 1.8);

                // Middle glow ring
                fill(0, 100, 100, 50);
                ellipse(this.x, this.y, this.size * 1.4);

                // Main hollow threat circle
                noFill();
                stroke(0, 100, 100);
                strokeWeight(3);
                ellipse(this.x, this.y, this.size);

                // Inner pulsing core
                let pulseSize = this.size * 0.4 + sin(frameCount * 0.15) * 5;
                fill(0, 100, 100, 90);
                noStroke();
                ellipse(this.x, this.y, pulseSize);

                // Draw threat name with glow
                fill(0, 0, 0, 120); // Dark background for readability
                noStroke();
                rectMode(CENTER);
                rect(this.x, this.y - this.size/2 - 25, textWidth(this.name) + 10, 25, 5);

                fill(0, 100, 100);
                textAlign(CENTER, CENTER);
                textSize(16); // Slightly smaller for better fit
                text(this.name, this.x, this.y - this.size/2 - 25);

                // Draw trajectory line with glow
                if (this.targetBase && !this.targetBase.isDestroyed) {
                    stroke(0, 100, 100, 40);
                    strokeWeight(2);
                    line(this.x, this.y, this.targetBase.x, this.targetBase.y);

                    // Dimmer background line for depth
                    stroke(0, 100, 100, 15);
                    strokeWeight(6);
                    line(this.x, this.y, this.targetBase.x, this.targetBase.y);
                }

                pop();
            }

            hasReachedTarget() {
                if (!this.targetBase) return false;
                const distance = dist(this.x, this.y, this.targetBase.x, this.targetBase.y);
                return distance < this.size/2 + this.targetBase.width/2;
            }

            retarget(newTargetBase) {
                this.targetBase = newTargetBase;
                // Recalculate trajectory to new target
                if (newTargetBase) {
                    const dx = newTargetBase.x - this.x;
                    const dy = newTargetBase.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                } else {
                    this.vx = 0;
                    this.vy = this.speed;
                }
            }
        }

        class Missile {
            constructor(startX, startY, targetX, targetY) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;

                // Calculate trajectory
                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * MISSILE_SPEED;
                this.vy = (dy / distance) * MISSILE_SPEED;

                this.trail = [];
            }

            update() {
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) {
                    this.trail.shift();
                }

                this.x += this.vx;
                this.y += this.vy;
            }

            render() {
                push();

                // Draw trail
                for (let i = 0; i < this.trail.length; i++) {
                    const alpha = map(i, 0, this.trail.length - 1, 0, 100);
                    stroke(180, 100, 100, alpha);
                    strokeWeight(2);
                    point(this.trail[i].x, this.trail[i].y);
                }

                // Draw missile
                fill(180, 100, 100);
                noStroke();
                ellipse(this.x, this.y, 6);

                pop();
            }

            hasReachedTarget() {
                const distance = dist(this.x, this.y, this.targetX, this.targetY);
                return distance < 10;
            }

            isOffScreen() {
                return this.x < -50 || this.x > width + 50 || this.y < -50 || this.y > height + 50;
            }
        }

        class Explosion {
            constructor(x, y, maxRadius) {
                this.x = x;
                this.y = y;
                this.maxRadius = maxRadius;
                this.currentRadius = 0;
                this.startTime = millis();
                this.duration = 1000; // 1 second for regular explosions
                this.isSystemReset = false; // Default to regular explosion
            }

            update() {
                let elapsed = millis() - this.startTime;
                let progress = elapsed / this.duration;
                this.currentRadius = progress * this.maxRadius;
            }

            getAlpha() {
                let elapsed = millis() - this.startTime;
                let progress = elapsed / this.duration;
                return map(progress, 0, 1, 80, 0);
            }

            render() {
                if (!this.isDead()) {
                    push();

                    const alpha = this.getAlpha();

                    // Outer ring
                    stroke(60, 100, 100, alpha);
                    strokeWeight(3);
                    noFill();
                    ellipse(this.x, this.y, this.currentRadius * 2);

                    // Inner glow
                    fill(60, 100, 100, alpha * 0.3);
                    noStroke();
                    ellipse(this.x, this.y, this.currentRadius);

                    pop();
                }
            }

            hits(enemy) {
                if (this.isDead()) return false;
                const distance = dist(this.x, this.y, enemy.x, enemy.y);
                return distance < this.currentRadius + enemy.size/2;
            }

            isDead() {
                let elapsed = millis() - this.startTime;
                return elapsed >= this.duration;
            }
        }
    </script>
</body>
</html>
